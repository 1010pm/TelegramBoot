/**
 * Telegram Bot + Firebase + Google APIs Integration
 * 
 * Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ù ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Cloud Functions Ù„Ù„Ù…Ø´Ø±ÙˆØ¹:
 * - telegramWebhook: Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø±Ø³Ø§Ø¦Ù„ Telegram
 * - oauthCallback: Ù…Ø¹Ø§Ù„Ø¬Ø© OAuth callback Ù…Ù† Google
 * - aiLogic: Ù…Ø­Ø§ÙƒÙŠ Ø¨Ø³ÙŠØ· Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù†ÙŠØ© (Intent) Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
 */

require('dotenv').config();
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const axios = require('axios');
const { google } = require('googleapis');

// ØªÙ‡ÙŠØ¦Ø© Firebase Admin SDK
admin.initializeApp();
const db = admin.firestore();

// =====================================
// Configuration
// =====================================

const config = {
  telegram: {
    token: process.env.TELEGRAM_BOT_TOKEN || functions.config().telegram?.token,
    apiUrl: null // Ø³ÙŠØªÙ… ØªØ¹ÙŠÙŠÙ†Ù‡ Ø¨Ø¹Ø¯ ØªØ­Ù…ÙŠÙ„ token
  },
  google: {
    clientId: process.env.GOOGLE_CLIENT_ID || functions.config().google?.client_id,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET || functions.config().google?.client_secret,
    redirectUri: process.env.OAUTH_REDIRECT_URI || functions.config().oauth?.redirect_uri
  },
  ai: {
    logicUrl: process.env.AI_LOGIC_URL || functions.config().ai?.url
  }
};

// ØªØ¹ÙŠÙŠÙ† Telegram API URL Ø¨Ø¹Ø¯ ØªØ­Ù…ÙŠÙ„ token
if (config.telegram.token) {
  config.telegram.apiUrl = `https://api.telegram.org/bot${config.telegram.token}`;
}

// =====================================
// Helper Functions
// =====================================

/**
 * Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¹Ø¨Ø± Telegram
 */
async function sendTelegramMessage(chatId, text, options = {}) {
  try {
    const response = await axios.post(`${config.telegram.apiUrl}/sendMessage`, {
      chat_id: chatId,
      text: text,
      parse_mode: options.parseMode || 'HTML',
      ...options
    });
    return response.data;
  } catch (error) {
    console.error('Error sending Telegram message:', error.response?.data || error.message);
    throw error;
  }
}

/**
 * ØªØ³Ø¬ÙŠÙ„ log ÙÙŠ Firestore
 */
async function logToFirestore(userId, level, message, meta = {}) {
  try {
    await db.collection('logs').add({
      userId,
      level,
      message,
      meta,
      timestamp: admin.firestore.FieldValue.serverTimestamp()
    });
  } catch (error) {
    console.error('Error logging to Firestore:', error);
  }
}

/**
 * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Google OAuth Client Ù…Ø¹ tokens Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©
 */
async function getGoogleOAuthClient(userId) {
  const tokenDoc = await db
    .collection('users')
    .doc(userId)
    .collection('tokens')
    .doc('google')
    .get();

  if (!tokenDoc.exists) {
    throw new Error('no_google_token');
  }

  const tokenData = tokenDoc.data();
  
  const oAuth2Client = new google.auth.OAuth2(
    config.google.clientId,
    config.google.clientSecret,
    config.google.redirectUri
  );

  oAuth2Client.setCredentials({
    access_token: tokenData.access_token,
    refresh_token: tokenData.refresh_token,
    expiry_date: tokenData.expiry_date
  });

  // ØªØ­Ø¯ÙŠØ« tokens ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¹Ù†Ø¯ Ø§Ù„ØªØ¬Ø¯ÙŠØ¯
  oAuth2Client.on('tokens', async (tokens) => {
    const updateData = {
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };

    if (tokens.access_token) {
      updateData.access_token = tokens.access_token;
    }
    if (tokens.refresh_token) {
      updateData.refresh_token = tokens.refresh_token;
    }
    if (tokens.expiry_date) {
      updateData.expiry_date = tokens.expiry_date;
    }

    try {
      await db
        .collection('users')
        .doc(userId)
        .collection('tokens')
        .doc('google')
        .update(updateData);
      
      console.log('Tokens updated successfully for user:', userId);
    } catch (error) {
      console.error('Error updating tokens:', error);
    }
  });

  return oAuth2Client;
}

/**
 * ØªÙˆÙ„ÙŠØ¯ Ø±Ø§Ø¨Ø· OAuth Ù„Ù€ Google
 */
function generateGoogleAuthUrl(userId, opId = null) {
  const oAuth2Client = new google.auth.OAuth2(
    config.google.clientId,
    config.google.clientSecret,
    config.google.redirectUri
  );

  const scopes = [
    'https://www.googleapis.com/auth/gmail.send',
    'https://www.googleapis.com/auth/calendar',
    'https://www.googleapis.com/auth/drive.file',
    'https://www.googleapis.com/auth/userinfo.email',
    'https://www.googleapis.com/auth/userinfo.profile'
  ];

  const state = JSON.stringify({ userId, opId });

  return oAuth2Client.generateAuthUrl({
    access_type: 'offline',
    scope: scopes,
    prompt: 'consent', // Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ refresh_token ÙÙŠ ÙƒÙ„ Ù…Ø±Ø©
    state: state
  });
}

/**
 * Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø³Ø§Ù„Ø© Ø¨Ø±ÙŠØ¯ Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø¨ØµÙŠØºØ© raw
 */
function makeRawEmail(to, subject, body, from = 'me') {
  const utf8Subject = `=?utf-8?B?${Buffer.from(subject).toString('base64')}?=`;
  const messageParts = [
    `From: ${from}`,
    `To: ${to}`,
    'Content-Type: text/plain; charset=utf-8',
    'MIME-Version: 1.0',
    `Subject: ${utf8Subject}`,
    '',
    body
  ];
  
  const message = messageParts.join('\n');
  const encodedMessage = Buffer.from(message)
    .toString('base64')
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/, '');
  
  return encodedMessage;
}

/**
 * Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Gemini AI Ù„Ù„Ø±Ø¯ Ø§Ù„Ø°ÙƒÙŠ
 */
async function getGeminiResponse(text, userId) {
  const geminiKey = process.env.GEMINI_API_KEY || functions.config().gemini?.key;
  
  if (!geminiKey) {
    return 'Ù…Ø±Ø­Ø¨Ø§Ù‹! ÙƒÙŠÙ ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ù…Ø³Ø§Ø¹Ø¯ØªÙƒØŸ';
  }

  try {
    const prompt = `Ø£Ù†Øª Ù…Ø³Ø§Ø¹Ø¯ Ø°ÙƒÙŠ Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© ØªØ³Ø§Ø¹Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙÙŠ:
1. Ø¥Ø±Ø³Ø§Ù„ Ø¥ÙŠÙ…ÙŠÙ„Ø§Øª Ø¹Ø¨Ø± Gmail
2. Ø¥Ø¶Ø§ÙØ© Ø£Ø­Ø¯Ø§Ø« ÙÙŠ Google Calendar  
3. Ø±ÙØ¹ Ù…Ù„ÙØ§Øª Ø¥Ù„Ù‰ Google Drive

Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: "${text}"

Ø±Ø¯ Ø¨Ø´ÙƒÙ„ Ø·Ø¨ÙŠØ¹ÙŠ ÙˆÙ…ÙÙŠØ¯. Ø¥Ø°Ø§ ÙƒØ§Ù† Ø·Ù„Ø¨ ÙˆØ§Ø¶Ø­ (Ù…Ø«Ù„ "Ø£Ø±Ø³Ù„ Ø§ÙŠÙ…ÙŠÙ„")ØŒ Ø£Ø®Ø¨Ø±Ù‡ Ø£Ù†Ùƒ Ø³ØªÙ†ÙØ°Ù‡. Ø¥Ø°Ø§ ÙƒØ§Ù† Ø³Ø¤Ø§Ù„ Ø¹Ø§Ù…ØŒ Ø£Ø¬Ø¨ Ø¨Ø´ÙƒÙ„ ÙˆØ¯ÙŠ.`;

    const response = await axios.post(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${geminiKey}`,
      {
        contents: [{
          parts: [{ text: prompt }]
        }]
      },
      {
        headers: { 'Content-Type': 'application/json' }
      }
    );

    const reply = response.data.candidates?.[0]?.content?.parts?.[0]?.text || 
                  'Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù„Ù… Ø£Ø³ØªØ·Ø¹ ÙÙ‡Ù… Ø·Ù„Ø¨Ùƒ.';
    
    return reply.trim();
    
  } catch (error) {
    console.error('Gemini API Error:', error.response?.data || error.message);
    return 'Ù…Ø±Ø­Ø¨Ø§Ù‹! ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø¥ÙŠÙ…ÙŠÙ„Ø§ØªØŒ Ø¥Ø¶Ø§ÙØ© Ø£Ø­Ø¯Ø§Ø«ØŒ Ø£Ùˆ Ø±ÙØ¹ Ù…Ù„ÙØ§Øª. ÙƒÙŠÙ ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ù…Ø³Ø§Ø¹Ø¯ØªÙƒØŸ';
  }
}

/**
 * Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ AI Logic Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù†ÙŠØ©
 */
async function callAiLogic(text, userId) {
  try {
    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ endpoint Ø®Ø§Ø±Ø¬ÙŠ
    if (config.ai.logicUrl && config.ai.logicUrl.includes('http')) {
      const response = await axios.post(config.ai.logicUrl, {
        text,
        userId,
        language: 'ar'
      });
      return response.data;
    }
    
    // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ù€ function Ø§Ù„Ù…Ø­Ù„ÙŠØ©
    return await extractIntent(text, userId);
  } catch (error) {
    console.error('Error calling AI Logic:', error);
    throw error;
  }
}

/**
 * Ù…Ø­Ø§ÙƒÙŠ Ø¨Ø³ÙŠØ· Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù†ÙŠØ© (Intent)
 * ÙÙŠ Ø§Ù„Ø¥Ù†ØªØ§Ø¬: Ø§Ø³ØªØ®Ø¯Ù… Vertex AI, Dialogflow, Ø£Ùˆ OpenAI
 */
function extractIntent(text, userId) {
  const lowerText = text.toLowerCase();
  
  // ÙƒÙ„Ù…Ø§Øª Ù…ÙØªØ§Ø­ÙŠØ© Ù„Ù„Ø¥ÙŠÙ…ÙŠÙ„
  if (lowerText.includes('Ø§ÙŠÙ…ÙŠÙ„') || lowerText.includes('Ø¨Ø±ÙŠØ¯') || lowerText.includes('email') || lowerText.includes('Ø£Ø±Ø³Ù„')) {
    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ
    const emailRegex = /([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9_-]+)/gi;
    const emails = text.match(emailRegex);
    
    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹
    let subject = 'Ø±Ø³Ø§Ù„Ø© Ù…Ù† Telegram Bot';
    const subjectMatch = text.match(/Ø¨Ø¹Ù†ÙˆØ§Ù†\s+"([^"]+)"|Ø¹Ù†ÙˆØ§Ù†\s+"([^"]+)"|Ø¨Ø®ØµÙˆØµ\s+"([^"]+)"/i);
    if (subjectMatch) {
      subject = subjectMatch[1] || subjectMatch[2] || subjectMatch[3];
    }
    
    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø±Ø³Ø§Ù„Ø©
    let message = text;
    const messageMatch = text.match(/(?:ÙˆØ§Ù„Ø±Ø³Ø§Ù„Ø©|Ø§Ù„Ø±Ø³Ø§Ù„Ø©|ØªÙ‚ÙˆÙ„ Ù„Ù‡|Ù‚Ù„ Ù„Ù‡)[:\s]+"?([^"]+)"?/i);
    if (messageMatch) {
      message = messageMatch[1];
    }
    
    return {
      action: 'send_email',
      confidence: emails ? 0.9 : 0.6,
      parameters: {
        recipient: emails ? emails[0] : null,
        subject: subject,
        message: message
      },
      followup_questions: emails ? [] : ['Ù…Ù† ÙØ¶Ù„ÙƒØŒ Ø­Ø¯Ø¯ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù„Ù„Ù…Ø³ØªÙ„Ù…']
    };
  }
  
  // ÙƒÙ„Ù…Ø§Øª Ù…ÙØªØ§Ø­ÙŠØ© Ù„Ù„ØªÙ‚ÙˆÙŠÙ…
  if (lowerText.includes('Ø­Ø¯Ø«') || lowerText.includes('Ø§Ø¬ØªÙ…Ø§Ø¹') || lowerText.includes('Ù…ÙˆØ¹Ø¯') || lowerText.includes('calendar')) {
    const titleMatch = text.match(/(?:Ø­Ø¯Ø«|Ø§Ø¬ØªÙ…Ø§Ø¹|Ù…ÙˆØ¹Ø¯)\s+(?:Ø¨Ø¹Ù†ÙˆØ§Ù†\s+)?"?([^"]+?)"?\s+(?:ÙÙŠ|ØºØ¯Ø§Ù‹|Ø§Ù„ÙŠÙˆÙ…)/i);
    
    return {
      action: 'create_event',
      confidence: 0.8,
      parameters: {
        title: titleMatch ? titleMatch[1] : 'Ø­Ø¯Ø« Ø¬Ø¯ÙŠØ¯',
        start: null, // ÙŠØ­ØªØ§Ø¬ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªØ§Ø±ÙŠØ® ÙˆØ§Ù„ÙˆÙ‚Øª
        end: null,
        description: text
      },
      followup_questions: ['Ù…ØªÙ‰ ØªØ±ÙŠØ¯ Ø§Ù„Ø­Ø¯Ø«ØŸ (Ù…Ø«Ø§Ù„: ØºØ¯Ø§Ù‹ Ø§Ù„Ø³Ø§Ø¹Ø© 10 ØµØ¨Ø§Ø­Ø§Ù‹)']
    };
  }
  
  // ÙƒÙ„Ù…Ø§Øª Ù…ÙØªØ§Ø­ÙŠØ© Ù„Ù„Ù…Ù„ÙØ§Øª
  if (lowerText.includes('Ù…Ù„Ù') || lowerText.includes('Ø±ÙØ¹') || lowerText.includes('upload') || lowerText.includes('drive')) {
    return {
      action: 'upload_file',
      confidence: 0.7,
      parameters: {
        fileName: null,
        destination: 'root'
      },
      followup_questions: ['Ø£Ø±Ø³Ù„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø±ÙØ¹Ù‡ Ø¥Ù„Ù‰ Drive']
    };
  }
  
  // Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ù†ÙŠØ©
  return {
    action: 'unknown',
    confidence: 0.0,
    parameters: {},
    followup_questions: ['Ù„Ù… Ø£ÙÙ‡Ù… Ø·Ù„Ø¨Ùƒ. ÙŠÙ…ÙƒÙ†Ùƒ Ø£Ù† ØªØ·Ù„Ø¨:\nâ€¢ Ø¥Ø±Ø³Ø§Ù„ Ø§ÙŠÙ…ÙŠÙ„\nâ€¢ Ø¥Ø¶Ø§ÙØ© Ø­Ø¯Ø« ÙÙŠ Ø§Ù„ØªÙ‚ÙˆÙŠÙ…\nâ€¢ Ø±ÙØ¹ Ù…Ù„Ù Ø¥Ù„Ù‰ Drive']
  };
}

// =====================================
// Cloud Functions
// =====================================

/**
 * Telegram Webhook - Ù†Ù‚Ø·Ø© Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø±Ø³Ø§Ø¦Ù„ Telegram
 */
exports.telegramWebhook = functions.https.onRequest(async (req, res) => {
  // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø·Ù„Ø¨
  if (req.method !== 'POST') {
    return res.status(405).send('Method Not Allowed');
  }

  try {
    const update = req.body;
    
    // ØªØ¬Ø§Ù‡Ù„ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª ØºÙŠØ± Ø§Ù„Ù†ØµÙŠØ©
    if (!update.message || !update.message.text) {
      return res.status(200).send('ok');
    }

    const chatId = update.message.chat.id;
    const text = update.message.text;
    const userId = `telegram:${chatId}`;

    console.log(`Received message from ${userId}: ${text}`);

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆØ¥Ù†Ø´Ø§Ø¦Ù‡ Ø¥Ù† Ù„Ø²Ù…
    const userRef = db.collection('users').doc(userId);
    const userDoc = await userRef.get();
    
    if (!userDoc.exists) {
      await userRef.set({
        telegramId: chatId,
        displayName: update.message.from.first_name || 'User',
        username: update.message.from.username || null,
        createdAt: admin.firestore.FieldValue.serverTimestamp()
      });
      
      await sendTelegramMessage(
        chatId,
        'ğŸ‰ Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ! Ø£Ù†Ø§ Ø¨ÙˆØª ÙŠØ³Ø§Ø¹Ø¯Ùƒ ÙÙŠ Ø¥Ø¯Ø§Ø±Ø© Ø­Ø³Ø§Ø¨Ùƒ Ø¹Ù„Ù‰ Google.\n\n' +
        'ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ ÙÙŠ:\n' +
        'ğŸ“§ Ø¥Ø±Ø³Ø§Ù„ Ø¥ÙŠÙ…ÙŠÙ„Ø§Øª Ø¹Ø¨Ø± Gmail\n' +
        'ğŸ“… Ø¥Ø¶Ø§ÙØ© Ø£Ø­Ø¯Ø§Ø« ÙÙŠ Google Calendar\n' +
        'ğŸ“ Ø±ÙØ¹ Ù…Ù„ÙØ§Øª Ø¥Ù„Ù‰ Google Drive\n\n' +
        'Ø¬Ø±Ù‘Ø¨ Ø£Ù† ØªÙ‚ÙˆÙ„: "Ø£Ø±Ø³Ù„ Ø§ÙŠÙ…ÙŠÙ„ Ù„Ø£Ø­Ù…Ø¯"'
      );
    }

    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù†ÙŠØ©
    const intent = await callAiLogic(text, userId);

    // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø±Ø³Ø§Ù„Ø© Ø¹Ø§Ø¯ÙŠØ© (Ù…Ø­Ø§Ø¯Ø«Ø© Ø¹Ø§Ù…Ø©)
    if (!intent || intent.action === 'unknown' || intent.confidence < 0.5) {
      const reply = `Ù…Ø±Ø­Ø¨Ø§Ù‹ ${update.message.from.first_name}! ğŸ‘‹

Ø£Ù†Ø§ Ø¨ÙˆØª Ø°ÙƒÙŠ ÙŠØ³Ø§Ø¹Ø¯Ùƒ ÙÙŠ:
ğŸ“§ Ø¥Ø±Ø³Ø§Ù„ Ø¥ÙŠÙ…ÙŠÙ„Ø§Øª Ø¹Ø¨Ø± Gmail
ğŸ“… Ø¥Ø¶Ø§ÙØ© Ø£Ø­Ø¯Ø§Ø« ÙÙŠ Google Calendar
ğŸ“ Ø±ÙØ¹ Ù…Ù„ÙØ§Øª Ø¥Ù„Ù‰ Google Drive

Ø¬Ø±Ø¨ Ø£Ù† ØªÙ‚ÙˆÙ„:
â€¢ "Ø£Ø±Ø³Ù„ Ø§ÙŠÙ…ÙŠÙ„ Ù„Ù€ ahmed@example.com"
â€¢ "Ø£Ø¶Ù Ø­Ø¯Ø« Ø§Ø¬ØªÙ…Ø§Ø¹ ØºØ¯Ø§Ù‹"
â€¢ "Ø§Ø±ÙØ¹ Ù…Ù„Ù report.pdf"`;
      
      await sendTelegramMessage(chatId, reply);
      return res.status(200).send('chat-reply');
    }
    
    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø£Ù…Ø± ÙˆØ§Ø¶Ø­
    const actionNames = {
      'send_email': 'Ø¥Ø±Ø³Ø§Ù„ Ø¥ÙŠÙ…ÙŠÙ„',
      'create_event': 'Ø¥Ø¶Ø§ÙØ© Ø­Ø¯Ø«',
      'upload_file': 'Ø±ÙØ¹ Ù…Ù„Ù'
    };
    
    const actionName = actionNames[intent.action] || intent.action;
    await sendTelegramMessage(chatId, `âœ… ÙÙ‡Ù…Øª! Ø³Ø£Ù‚ÙˆÙ… Ø¨Ù€: ${actionName}`);

    // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©
    const opRef = await db.collection('operations').add({
      userId,
      action: intent.action,
      params: intent.parameters || {},
      status: 'pending',
      confidence: intent.confidence,
      createdAt: admin.firestore.FieldValue.serverTimestamp()
    });

    await logToFirestore(userId, 'info', `New operation: ${intent.action}`, { opId: opRef.id });

    // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡
    await processAction(intent, userId, chatId, opRef);

    return res.status(200).send('ok');

  } catch (error) {
    console.error('Error in telegramWebhook:', error);
    return res.status(500).send('Internal Server Error');
  }
});

/**
 * Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø­Ø³Ø¨ Ø§Ù„Ù†ÙŠØ©
 */
async function processAction(intent, userId, chatId, opRef) {
  const { action, parameters } = intent;

  try {
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ tokens
    let oAuth2Client;
    try {
      oAuth2Client = await getGoogleOAuthClient(userId);
    } catch (error) {
      if (error.message === 'no_google_token') {
        const authUrl = generateGoogleAuthUrl(userId, opRef.id);
        await sendTelegramMessage(
          chatId,
          'ğŸ” Ù„ØªÙ†ÙÙŠØ° Ù‡Ø°Ø§ Ø§Ù„Ø·Ù„Ø¨ØŒ Ø£Ø­ØªØ§Ø¬ Ø£Ù† ØªØ±Ø¨Ø· Ø­Ø³Ø§Ø¨ Google Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ.\n\n' +
          'Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø§Ø¨Ø· Ø£Ø¯Ù†Ø§Ù‡ ÙˆØ§Ù…Ù†Ø­ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª:\n' +
          authUrl +
          '\n\nØ¨Ø¹Ø¯ Ø§Ù„Ø±Ø¨Ø·ØŒ Ø£Ø±Ø³Ù„ Ø·Ù„Ø¨Ùƒ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.'
        );
        
        await opRef.update({
          status: 'waiting_auth',
          authUrl: authUrl
        });
        
        return;
      }
      throw error;
    }

    // ØªÙ†ÙÙŠØ° Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ø­Ø³Ø¨ Ø§Ù„Ù†ÙˆØ¹
    switch (action) {
      case 'send_email':
        await handleSendEmail(oAuth2Client, parameters, userId, chatId, opRef);
        break;

      case 'create_event':
        await handleCreateEvent(oAuth2Client, parameters, userId, chatId, opRef);
        break;

      case 'upload_file':
        await handleUploadFile(oAuth2Client, parameters, userId, chatId, opRef);
        break;

      default:
        await sendTelegramMessage(
          chatId,
          `âš ï¸ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ "${action}" ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ… Ø­Ø§Ù„ÙŠØ§Ù‹.\n\n` +
          'Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø©:\n' +
          'â€¢ send_email\n' +
          'â€¢ create_event\n' +
          'â€¢ upload_file'
        );
        await opRef.update({
          status: 'unsupported',
          finishedAt: admin.firestore.FieldValue.serverTimestamp()
        });
    }

  } catch (error) {
    console.error('Error processing action:', error);
    await sendTelegramMessage(
      chatId,
      `âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙ†ÙÙŠØ° Ø§Ù„Ø¹Ù…Ù„ÙŠØ©:\n${error.message}`
    );
    
    await opRef.update({
      status: 'failed',
      error: error.message,
      finishedAt: admin.firestore.FieldValue.serverTimestamp()
    });
    
    await logToFirestore(userId, 'error', 'Action processing failed', {
      action: intent.action,
      error: error.message
    });
  }
}

/**
 * Ø¥Ø±Ø³Ø§Ù„ Ø¥ÙŠÙ…ÙŠÙ„ Ø¹Ø¨Ø± Gmail API
 */
async function handleSendEmail(oAuth2Client, params, userId, chatId, opRef) {
  const { recipient, subject, message } = params;

  // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
  if (!recipient) {
    await sendTelegramMessage(chatId, 'âŒ Ù„Ù… ØªØ­Ø¯Ø¯ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù„Ù„Ù…Ø³ØªÙ„Ù….');
    await opRef.update({ status: 'failed', error: 'Missing recipient' });
    return;
  }

  const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });
  const raw = makeRawEmail(recipient, subject || 'Ø±Ø³Ø§Ù„Ø© Ù…Ù† Telegram Bot', message || '');

  try {
    const result = await gmail.users.messages.send({
      userId: 'me',
      requestBody: { raw }
    });

    await sendTelegramMessage(
      chatId,
      `âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­ Ø¥Ù„Ù‰ <b>${recipient}</b>\n\n` +
      `Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹: ${subject || 'Ø±Ø³Ø§Ù„Ø© Ù…Ù† Telegram Bot'}`,
      { parseMode: 'HTML' }
    );

    await opRef.update({
      status: 'success',
      result: { messageId: result.data.id },
      finishedAt: admin.firestore.FieldValue.serverTimestamp()
    });

    await logToFirestore(userId, 'info', 'Email sent successfully', {
      recipient,
      messageId: result.data.id
    });

  } catch (error) {
    console.error('Error sending email:', error);
    throw new Error(`ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„: ${error.message}`);
  }
}

/**
 * Ø¥Ø¶Ø§ÙØ© Ø­Ø¯Ø« ÙÙŠ Google Calendar
 */
async function handleCreateEvent(oAuth2Client, params, userId, chatId, opRef) {
  const { title, start, end, description } = params;

  await sendTelegramMessage(
    chatId,
    'âš ï¸ Ù…ÙŠØ²Ø© Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø£Ø­Ø¯Ø§Ø« ÙÙŠ Ø§Ù„ØªÙ‚ÙˆÙŠÙ… Ù‚ÙŠØ¯ Ø§Ù„ØªØ·ÙˆÙŠØ±.\n\n' +
    'Ø­Ø§Ù„ÙŠØ§Ù‹ ØªØ­ØªØ§Ø¬ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ØªØ§Ø±ÙŠØ® ÙˆØ§Ù„ÙˆÙ‚Øª Ø¨Ø¯Ù‚Ø©.\n' +
    'Ù…Ø«Ø§Ù„: "Ø£Ø¶Ù Ø­Ø¯Ø« Ø§Ø¬ØªÙ…Ø§Ø¹ Ø§Ù„ÙØ±ÙŠÙ‚ ÙŠÙˆÙ… 2025-11-15 Ù…Ù† 10:00 Ø¥Ù„Ù‰ 11:00"'
  );

  await opRef.update({
    status: 'in_development',
    finishedAt: admin.firestore.FieldValue.serverTimestamp()
  });
}

/**
 * Ø±ÙØ¹ Ù…Ù„Ù Ø¥Ù„Ù‰ Google Drive
 */
async function handleUploadFile(oAuth2Client, params, userId, chatId, opRef) {
  await sendTelegramMessage(
    chatId,
    'âš ï¸ Ù…ÙŠØ²Ø© Ø±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª Ø¥Ù„Ù‰ Drive Ù‚ÙŠØ¯ Ø§Ù„ØªØ·ÙˆÙŠØ±.\n\n' +
    'Ø³ÙŠØªÙ… Ø¥Ø¶Ø§ÙØªÙ‡Ø§ Ù‚Ø±ÙŠØ¨Ø§Ù‹ Ø¨Ø­ÙŠØ« ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ù…Ù„Ù Ø¹Ø¨Ø± Telegram ÙˆØ±ÙØ¹Ù‡ Ù…Ø¨Ø§Ø´Ø±Ø©.'
  );

  await opRef.update({
    status: 'in_development',
    finishedAt: admin.firestore.FieldValue.serverTimestamp()
  });
}

/**
 * OAuth Callback - Ù…Ø¹Ø§Ù„Ø¬Ø© Ø±Ø¯ Google OAuth
 */
exports.oauthCallback = functions.https.onRequest(async (req, res) => {
  try {
    const { code, state } = req.query;

    if (!code) {
      return res.status(400).send('Missing authorization code');
    }

    // ÙÙƒ ØªØ´ÙÙŠØ± state
    let stateData;
    try {
      stateData = JSON.parse(state);
    } catch (error) {
      return res.status(400).send('Invalid state parameter');
    }

    const { userId, opId } = stateData;

    // ØªØ¨Ø¯ÙŠÙ„ code Ø¨Ù€ tokens
    const oAuth2Client = new google.auth.OAuth2(
      config.google.clientId,
      config.google.clientSecret,
      config.google.redirectUri
    );

    const { tokens } = await oAuth2Client.getToken(code);

    // Ø­ÙØ¸ tokens ÙÙŠ Firestore
    await db
      .collection('users')
      .doc(userId)
      .collection('tokens')
      .doc('google')
      .set({
        access_token: tokens.access_token,
        refresh_token: tokens.refresh_token,
        scope: tokens.scope,
        expiry_date: tokens.expiry_date,
        token_type: tokens.token_type,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp()
      });

    await logToFirestore(userId, 'info', 'Google account connected successfully');

    // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ØªØ£ÙƒÙŠØ¯ Ø¹Ø¨Ø± Telegram
    const telegramId = userId.replace('telegram:', '');
    await sendTelegramMessage(
      telegramId,
      'âœ… ØªÙ… Ø±Ø¨Ø· Ø­Ø³Ø§Ø¨ Google Ø¨Ù†Ø¬Ø§Ø­!\n\n' +
      'ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ÙŠØ²Ø§Øª. Ø¬Ø±Ù‘Ø¨:\n' +
      'â€¢ Ø£Ø±Ø³Ù„ Ø§ÙŠÙ…ÙŠÙ„ Ù„Ù€ example@gmail.com\n' +
      'â€¢ Ø£Ø¶Ù Ø­Ø¯Ø« ÙÙŠ Ø§Ù„ØªÙ‚ÙˆÙŠÙ…\n' +
      'â€¢ Ø§Ø±ÙØ¹ Ù…Ù„Ù'
    );

    // ØµÙØ­Ø© HTML Ù„Ù„Ù†Ø¬Ø§Ø­
    res.send(`
      <!DOCTYPE html>
      <html dir="rtl" lang="ar">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>ØªÙ… Ø§Ù„Ø±Ø¨Ø· Ø¨Ù†Ø¬Ø§Ø­</title>
        <style>
          body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
          }
          .container {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            text-align: center;
            max-width: 500px;
          }
          .success-icon {
            font-size: 80px;
            margin-bottom: 20px;
          }
          h1 {
            color: #2d3748;
            margin-bottom: 10px;
          }
          p {
            color: #718096;
            font-size: 18px;
            line-height: 1.6;
          }
          .button {
            display: inline-block;
            margin-top: 20px;
            padding: 12px 30px;
            background: #667eea;
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: bold;
          }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="success-icon">âœ…</div>
          <h1>ØªÙ… Ø§Ù„Ø±Ø¨Ø· Ø¨Ù†Ø¬Ø§Ø­!</h1>
          <p>ØªÙ… Ø±Ø¨Ø· Ø­Ø³Ø§Ø¨ Google Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù…Ø¹ Telegram Bot</p>
          <p>Ø§Ø±Ø¬Ø¹ Ø¥Ù„Ù‰ Telegram ÙˆØ¬Ø±Ù‘Ø¨ Ø¥Ø±Ø³Ø§Ù„ Ø£Ù…Ø± Ø¬Ø¯ÙŠØ¯</p>
          <a href="https://t.me/${process.env.BOT_USERNAME || 'YourBot'}" class="button">Ø§ÙØªØ­ Telegram</a>
        </div>
      </body>
      </html>
    `);

  } catch (error) {
    console.error('Error in OAuth callback:', error);
    res.status(500).send(`
      <!DOCTYPE html>
      <html dir="rtl" lang="ar">
      <head>
        <meta charset="UTF-8">
        <title>Ø®Ø·Ø£</title>
        <style>
          body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f7fafc;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
          }
          .container {
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            text-align: center;
          }
          .error-icon {
            font-size: 60px;
            margin-bottom: 20px;
          }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="error-icon">âŒ</div>
          <h1>Ø­Ø¯Ø« Ø®Ø·Ø£</h1>
          <p>${error.message}</p>
        </div>
      </body>
      </html>
    `);
  }
});

/**
 * AI Logic Endpoint - Ù…Ø­Ø§ÙƒÙŠ Ø¨Ø³ÙŠØ· (ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ¨Ø¯Ø§Ù„Ù‡ Ø¨Ø®Ø¯Ù…Ø© Ø®Ø§Ø±Ø¬ÙŠØ©)
 */
exports.aiLogic = functions.https.onRequest(async (req, res) => {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method Not Allowed' });
  }

  try {
    const { text, userId, language } = req.body;

    if (!text) {
      return res.status(400).json({ error: 'Missing text parameter' });
    }

    const intent = extractIntent(text, userId);
    
    return res.status(200).json(intent);

  } catch (error) {
    console.error('Error in AI Logic:', error);
    return res.status(500).json({ error: error.message });
  }
});

// =====================================
// Utility Functions Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠ
// =====================================

/**
 * Ø¯Ø§Ù„Ø© scheduled Ù„ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)
 */
exports.cleanupOldOperations = functions.pubsub
  .schedule('every 24 hours')
  .onRun(async (context) => {
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const snapshot = await db
      .collection('operations')
      .where('createdAt', '<', thirtyDaysAgo)
      .limit(500)
      .get();

    const batch = db.batch();
    snapshot.docs.forEach((doc) => {
      batch.delete(doc.ref);
    });

    await batch.commit();
    console.log(`Deleted ${snapshot.size} old operations`);
  });
